# Core OOP Concepts

# 1. Four Pillars of OOP

### 1. Encapsulation
Encapsulation is the process of wrapping data and methods that operate on the data into a single unit, such as a class. It helps in data hiding and controlled access through getters and setters.

**Example**
<pre>
class Account {
    private double balance;

    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
}
</pre>

---

### 2. Abstraction
Abstraction hides the implementation details and exposes only the functionality.

**Example: Abstract Class**
<pre>
abstract class Vehicle {
    abstract void start();
}

class Car extends Vehicle {
    void start() {
        System.out.println("Car started");
    }
}
</pre>

---

### 3. Inheritance
Inheritance allows a child class to acquire properties and behavior from a parent class.

**Example**
<pre>
class Animal {
    void eat() {
        System.out.println("Eating...");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Barking...");
    }
}
</pre>

---

### 4. Polymorphism
Polymorphism allows methods or objects to take multiple forms.

**Method Overloading (Compile-time Polymorphism)**
<pre>
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
}
</pre>

**Method Overriding (Runtime Polymorphism)**
<pre>
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}
</pre>

---

# 2. Difference Between Abstract Class and Interface

| Feature               | Abstract Class                      | Interface                       |
|-----------------------|-------------------------------------|----------------------------------|
| **Methods**           | Can have both abstract and concrete methods | All methods are abstract (before Java 8) |
| **Variables**         | Can have instance variables         | Only constants (static final)    |
| **Multiple Inheritance** | Single inheritance only            | Can implement multiple interfaces |
| **Use Case**          | Shared code among related classes   | Define a contract for unrelated classes |

**Example: Abstract Class**
<pre>
abstract class Shape {
    abstract void draw();
    void color() {
        System.out.println("Coloring shape");
    }
}
</pre>

**Example: Interface**
<pre>
interface Drawable {
    void draw();
}
</pre>

---

# 3. Method Overloading and Method Overriding

### Method Overloading
- **Definition**: Methods in the same class with the same name but different parameter lists.
- **Rules**:
  - Same method name, different parameters.
  - Can change the return type.
  - Happens at compile time.

**Example**
<pre>
class Printer {
    void print(String text) {
        System.out.println(text);
    }

    void print(int number) {
        System.out.println(number);
    }
}
</pre>

### Method Overriding
- **Definition**: A subclass provides a specific implementation for a method in the parent class.
- **Rules**:
  - Same method name, return type, and parameters.
  - The method in the child class must not have a stricter access modifier than the parent class.
  - Happens at runtime.

**Example**
<pre>
class Parent {
    void show() {
        System.out.println("Parent show");
    }
}

class Child extends Parent {
    @Override
    void show() {
        System.out.println("Child show");
    }
}
</pre>

---

# 4. Composition vs Inheritance

### Inheritance
- Models an "is-a" relationship.
- Tight coupling between parent and child classes.
- Changes in the parent class affect all child classes.

**Example**
<pre>
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car extends Engine {
}
</pre>

### Composition
- Models a "has-a" relationship.
- Looser coupling by using objects within a class.
- More flexible and reusable.

**Example**
<pre>
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine();

    void startCar() {
        engine.start();
    }
}
</pre>

### Why Composition is Preferred
1. **Flexibility**: Allows changing relationships at runtime.
2. **Loose Coupling**: Reduces dependencies between components.
3. **Reuse**: Promotes code reuse by using existing components.

**Preferred Scenario**
For example, a `Car` class "has-a" `Engine`, but an `Engine` can be shared across different car models without modifying the engine class.


# 1. Difference Between a Class and an Object

### Class
- A blueprint or template for creating objects.
- Defines properties (fields) and behaviors (methods).

**Example**
<pre>
class Car {
    String brand;
    void drive() {
        System.out.println("Driving a car");
    }
}
</pre>

### Object
- An instance of a class.
- Represents a specific entity with actual values.

**Example**
<pre>
Car myCar = new Car();
myCar.brand = "Toyota";
myCar.drive();
</pre>

**Real-World Analogy**
- **Class**: Blueprint of a house.
- **Object**: The actual house built using the blueprint.

---

# 2. Polymorphism

### Definition
Polymorphism allows methods or objects to take multiple forms.

### Compile-Time Polymorphism (Method Overloading)
<pre>
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
}
</pre>

### Runtime Polymorphism (Method Overriding)
<pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}
</pre>

---

# 3. Encapsulation

### Definition
Encapsulation is wrapping data and methods that operate on the data into a single unit, like a class. It provides controlled access to fields through getters and setters.

**Example**
<pre>
class Account {
    private double balance;

    public double getBalance() {
        return balance;
    }

    public void setBalance(double amount) {
        if (amount >= 0) {
            balance = amount;
        }
    }
}
</pre>

---

# 4. Access Modifiers

### Definition
Access modifiers define the visibility of classes, methods, and fields.

| Modifier    | Visibility                                   |
|-------------|---------------------------------------------|
| **public**  | Accessible from anywhere.                  |
| **private** | Accessible only within the declaring class. |
| **protected** | Accessible within the same package and subclasses. |

**Example**
<pre>
class Example {
    public int publicVar;
    private int privateVar;
    protected int protectedVar;
}
</pre>

---

# 5. Abstraction

### Definition
Abstraction hides implementation details and shows only the essential features.

**Abstract Class**
<pre>
abstract class Vehicle {
    abstract void start();
}
</pre>

**Interface**
<pre>
interface Driveable {
    void drive();
}
</pre>

**Can a Class Implement Multiple Interfaces?**
Yes, a class can implement multiple interfaces to provide a contract for multiple behaviors.

---

# 6. Interface vs Abstract Class

### Key Differences
| Feature        | Abstract Class                    | Interface                       |
|----------------|------------------------------------|----------------------------------|
| Methods        | Abstract and concrete methods     | Abstract methods only (before Java 8) |
| Variables      | Instance variables allowed        | Only static final constants     |

**Scenario for Abstract Class**
Use an abstract class when some methods have shared code that needs to be inherited by subclasses.

---

# 7. Inheritance vs Composition

### Inheritance
- Models an "is-a" relationship.
- Tight coupling between parent and child classes.

### Composition
- Models a "has-a" relationship.
- Promotes loose coupling.

**Example**
<pre>
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine();

    void startCar() {
        engine.start();
    }
}
</pre>

---

# 8. Multiple Inheritance

### Definition
Multiple inheritance allows a class to inherit from multiple parent classes.

**Why Not Supported in Java?**
To avoid ambiguity caused by the **Diamond Problem**.

**Example Using Interfaces**
<pre>
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class C implements A, B {
    public void methodA() {
        System.out.println("Method A");
    }

    public void methodB() {
        System.out.println("Method B");
    }
}
</pre>

---

# 9. Significance of `this` Keyword

### Definition
`this` refers to the current instance of the class.

**Example**
<pre>
class Example {
    private int value;

    Example(int value) {
        this.value = value; // Refers to the instance variable
    }

    void display() {
        System.out.println("Value: " + this.value);
    }
}
</pre>

---

# 10. Method Overriding

### Definition
Method overriding allows a subclass to provide a specific implementation for a method defined in its parent class.

### Rules
1. Same method name, return type, and parameters.
2. The method in the child class cannot have stricter access than the parent class.

**Example**
<pre>
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child display");
    }
}
</pre>



# Design-Oriented Questions

# 5. Library Management System Class Hierarchy

### Class Design
1. **Book**: Represents books in the library.
2. **Member**: Represents library members.
3. **Librarian**: Manages library operations.
4. **BorrowTransaction**: Handles book borrowing and returning.

### Code Example
<pre>
class Book {
    private String title;
    private String author;
    private boolean isBorrowed;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.isBorrowed = false;
    }

    public void borrow() {
        isBorrowed = true;
    }

    public void returnBook() {
        isBorrowed = false;
    }
}

class Member {
    private String name;
    private int memberId;

    public Member(String name, int memberId) {
        this.name = name;
        this.memberId = memberId;
    }
}

class Librarian {
    public void manageBooks() {
        System.out.println("Managing books...");
    }
}

class BorrowTransaction {
    private Book book;
    private Member member;

    public BorrowTransaction(Book book, Member member) {
        this.book = book;
        this.member = member;
    }

    public void borrowBook() {
        book.borrow();
    }

    public void returnBook() {
        book.returnBook();
    }
}
</pre>

### OOP Concepts Used
- **Inheritance**: Librarian and Member can inherit a common `Person` class.
- **Polymorphism**: Transactions can have multiple types like borrow or return.
- **Interfaces**: Define contracts for managing books and members.

---

# 6. Parking Lot System Design

### Class Design
1. **ParkingSpot**: Represents individual parking spots.
2. **Vehicle**: Represents different types of vehicles (Car, Bike, etc.).
3. **Ticket**: Records parking details.
4. **ParkingLot**: Manages all operations.

### Code Example
<pre>
class ParkingSpot {
    private int spotNumber;
    private boolean isOccupied;

    public ParkingSpot(int spotNumber) {
        this.spotNumber = spotNumber;
        this.isOccupied = false;
    }

    public void occupy() {
        isOccupied = true;
    }

    public void vacate() {
        isOccupied = false;
    }
}

class Vehicle {
    private String licensePlate;
    private String type;

    public Vehicle(String licensePlate, String type) {
        this.licensePlate = licensePlate;
        this.type = type;
    }
}

class Ticket {
    private Vehicle vehicle;
    private ParkingSpot spot;

    public Ticket(Vehicle vehicle, ParkingSpot spot) {
        this.vehicle = vehicle;
        this.spot = spot;
    }
}

class ParkingLot {
    private List<ParkingSpot> spots;

    public ParkingLot(int capacity) {
        spots = new ArrayList<>();
        for (int i = 1; i <= capacity; i++) {
            spots.add(new ParkingSpot(i));
        }
    }

    public ParkingSpot findAvailableSpot() {
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied()) {
                return spot;
            }
        }
        return null;
    }
}
</pre>

---

# 7. Singleton Pattern

### What is Singleton?
A design pattern ensuring only one instance of a class exists.

### Thread-Safe Singleton (Lazy Initialization)
<pre>
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</pre>

### Eager Initialization
<pre>
class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
</pre>

---

# 8. Factory Design Pattern

### What is the Factory Pattern?
A creational pattern that provides an interface for creating objects without specifying the exact class.

### Example: Shape Factory
<pre>
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type) {
            case "Circle": return new Circle();
            case "Rectangle": return new Rectangle();
            default: throw new IllegalArgumentException("Unknown shape");
        }
    }
}
</pre>

---

# 9. Dependency Injection (DI)

### What is Dependency Injection?
DI is a design pattern where objects are provided with their dependencies rather than creating them internally.

### Example
<pre>
interface Service {
    void execute();
}

class MyService implements Service {
    public void execute() {
        System.out.println("Service executed");
    }
}

class Client {
    private Service service;

    public Client(Service service) {
        this.service = service; // Dependency is injected
    }

    public void performTask() {
        service.execute();
    }
}

public class Main {
    public static void main(String[] args) {
        Service service = new MyService();
        Client client = new Client(service);
        client.performTask();
    }
}
</pre>

### Why Use DI?
1. Promotes loose coupling.
2. Enhances testability.
3. Improves code maintainability.

# 21. Transportation System Class Hierarchy

### Classes and Methods
1. **Vehicle**: Base class with `start()` and `stop()` methods.
2. **Car**, **Bike**, **Truck**: Inherit from `Vehicle` and add specific behaviors.

<pre>
abstract class Vehicle {
    void start() {
        System.out.println("Vehicle started");
    }
    void stop() {
        System.out.println("Vehicle stopped");
    }
}

class Car extends Vehicle {
    void playMusic() {
        System.out.println("Playing music");
    }
}

class Bike extends Vehicle {
    void doWheelie() {
        System.out.println("Doing a wheelie");
    }
}

class Truck extends Vehicle {
    void loadCargo() {
        System.out.println("Loading cargo");
    }
}
</pre>

---

# 22. Basic ATM System

### Classes and Relationships
1. **Account**: Manages balance and transactions.
2. **Customer**: Holds account details.
3. **Bank**: Contains multiple customers and handles transactions.
4. **Transaction**: Represents deposits and withdrawals.

<pre>
class Account {
    private double balance;

    public void deposit(double amount) {
        balance += amount;
    }

    public void withdraw(double amount) {
        if (balance >= amount) balance -= amount;
    }

    public double getBalance() {
        return balance;
    }
}

class Customer {
    private String name;
    private Account account;

    public Customer(String name, Account account) {
        this.name = name;
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }
}

class Transaction {
    private Customer customer;
    private String type;
    private double amount;

    public Transaction(Customer customer, String type, double amount) {
        this.customer = customer;
        this.type = type;
        this.amount = amount;
    }

    public void process() {
        if (type.equals("deposit")) customer.getAccount().deposit(amount);
        else if (type.equals("withdraw")) customer.getAccount().withdraw(amount);
    }
}
</pre>

---

# 23. Simple E-Commerce System

### Classes and Relationships
1. **Product**: Represents items.
2. **User**: Customer of the platform.
3. **Cart**: Aggregates products.
4. **Order**: Composed of cart and user details.

<pre>
class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public double getPrice() {
        return price;
    }
}

class User {
    private String username;
    public User(String username) {
        this.username = username;
    }
}

class Cart {
    private List<Product> products = new ArrayList<>();

    public void addProduct(Product product) {
        products.add(product);
    }

    public List<Product> getProducts() {
        return products;
    }
}

class Order {
    private User user;
    private Cart cart;

    public Order(User user, Cart cart) {
        this.user = user;
        this.cart = cart;
    }
}
</pre>

---

# 24. Thread-Safe Singleton Pattern

<pre>
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</pre>

---

# 25. Factory Design Pattern

<pre>
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing Square");
    }
}

class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type) {
            case "Circle": return new Circle();
            case "Square": return new Square();
            default: throw new IllegalArgumentException("Unknown shape type");
        }
    }
}
</pre>

---

# 26. Observer Pattern

<pre>
interface Subscriber {
    void update(String news);
}

class NewsPublisher {
    private List<Subscriber> subscribers = new ArrayList<>();

    public void subscribe(Subscriber sub) {
        subscribers.add(sub);
    }

    public void notifySubscribers(String news) {
        for (Subscriber sub : subscribers) {
            sub.update(news);
        }
    }
}

class EmailSubscriber implements Subscriber {
    public void update(String news) {
        System.out.println("Email received: " + news);
    }
}
</pre>

---

# 27. Zoo Management System

<pre>
abstract class Animal {
    abstract void makeSound();
}

class Mammal extends Animal {
    void makeSound() {
        System.out.println("Mammal sound");
    }
}

class Bird extends Animal {
    void makeSound() {
        System.out.println("Bird chirp");
    }
}

class ZooKeeper {
    void feedAnimal(Animal animal) {
        System.out.println("Feeding animal");
    }
}
</pre>

---

# 28. Builder Pattern

<pre>
class Car {
    private String color;
    private boolean hasSunroof;

    public static class Builder {
        private String color;
        private boolean hasSunroof;

        public Builder setColor(String color) {
            this.color = color;
            return this;
        }

        public Builder setSunroof(boolean hasSunroof) {
            this.hasSunroof = hasSunroof;
            return this;
        }

        public Car build() {
            return new Car(this);
        }
    }

    private Car(Builder builder) {
        this.color = builder.color;
        this.hasSunroof = builder.hasSunroof;
    }
}
</pre>

---

# 29. Parking Lot System

<pre>
class ParkingSpot {
    private boolean isOccupied;

    public void occupy() {
        isOccupied = true;
    }

    public void vacate() {
        isOccupied = false;
    }
}

class Vehicle {
    private String licensePlate;
}

class ParkingLot {
    private List<ParkingSpot> spots;

    public ParkingLot(int capacity) {
        spots = new ArrayList<>();
        for (int i = 0; i < capacity; i++) {
            spots.add(new ParkingSpot());
        }
    }

    public ParkingSpot findSpot() {
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied()) return spot;
        }
        return null;
    }
}
</pre>

---

# 30. Scalable Notification System

### Design
1. **Notification**: Abstract base class.
2. **EmailNotification**, **SMSNotification**: Implement specific behaviors.
3. **NotificationService**: Sends notifications based on type.

<pre>
abstract class Notification {
    abstract void send(String message);
}

class EmailNotification extends Notification {
    void send(String message) {
        System.out.println("Email sent: " + message);
    }
}

class SMSNotification extends Notification {
    void send(String message) {
        System.out.println("SMS sent: " + message);
    }
}

class NotificationService {
    public void notifyUser(Notification notification, String message) {
        notification.send(message);
    }
}
</pre>


# Coding Challenges

# 10. Polymorphism Demonstration

### Example: Shape Class with Derived Circle and Rectangle Classes
<pre>
class Shape {
    void draw() {
        System.out.println("Drawing a shape");
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a Circle");
    }
}

class Rectangle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a Rectangle");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Rectangle();

        shape1.draw(); // Output: Drawing a Circle
        shape2.draw(); // Output: Drawing a Rectangle
    }
}
</pre>

---

# 11. Employee Management System

### Classes: Employee, Manager, Department
<pre>
class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public double calculateSalary() {
        return salary;
    }

    public void assignTask(String task) {
        System.out.println(name + " is assigned to: " + task);
    }
}

class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }

    @Override
    public double calculateSalary() {
        return super.calculateSalary() + bonus;
    }
}

class Department {
    private String name;
    private List<Employee> employees;

    public Department(String name) {
        this.name = name;
        this.employees = new ArrayList<>();
    }

    public void addEmployee(Employee employee) {
        employees.add(employee);
    }

    public void displayEmployees() {
        for (Employee employee : employees) {
            System.out.println(employee.calculateSalary());
        }
    }
}
</pre>

---

# 12. Zoo Class Structure

### Classes: Animal, Mammal, Bird, Zoo
<pre>
abstract class Animal {
    abstract void makeSound();
}

class Mammal extends Animal {
    @Override
    void makeSound() {
        System.out.println("Mammal sound");
    }
}

class Bird extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bird chirp");
    }
}

class Zoo {
    private List<Animal> animals;

    public Zoo() {
        this.animals = new ArrayList<>();
    }

    public void addAnimal(Animal animal) {
        animals.add(animal);
    }

    public void makeAllAnimalsSound() {
        for (Animal animal : animals) {
            animal.makeSound();
        }
    }
}
</pre>

---

# 13. Simple Banking System

### Classes: Account, Customer, Transaction
<pre>
class Account {
    private double balance;

    public Account(double initialBalance) {
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
        } else {
            System.out.println("Insufficient funds");
        }
    }

    public double getBalance() {
        return balance;
    }
}

class Customer {
    private String name;
    private Account account;

    public Customer(String name, double initialBalance) {
        this.name = name;
        this.account = new Account(initialBalance);
    }

    public Account getAccount() {
        return account;
    }
}

class Transaction {
    private Customer customer;

    public Transaction(Customer customer) {
        this.customer = customer;
    }

    public void processDeposit(double amount) {
        customer.getAccount().deposit(amount);
        System.out.println("Deposited: " + amount);
    }

    public void processWithdrawal(double amount) {
        customer.getAccount().withdraw(amount);
        System.out.println("Withdrawn: " + amount);
    }
}

public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer("John Doe", 1000);
        Transaction transaction = new Transaction(customer);

        transaction.processDeposit(500); // Deposited: 500
        transaction.processWithdrawal(300); // Withdrawn: 300
        System.out.println("Balance: " + customer.getAccount().getBalance()); // Balance: 1200
    }
}
</pre>


# Advanced OOP Concepts

# 14. Access Modifiers in OOP

### Types of Access Modifiers in Java
| Modifier    | Visibility                                                                 |
|-------------|----------------------------------------------------------------------------|
| **public**  | Accessible from anywhere.                                                 |
| **private** | Accessible only within the defining class.                                |
| **protected** | Accessible within the same package and subclasses.                      |
| **default** | (Package-Private) Accessible within the same package.                     |

**Example**
<pre>
class Example {
    public int publicField = 10;
    private int privateField = 20;
    protected int protectedField = 30;
    int defaultField = 40; // Package-private
}
</pre>

---

# 15. Immutability in OOP

### What is Immutability?
Immutability means an object's state cannot be changed after creation.

### How to Design Immutable Objects in Java
1. Declare the class as `final`.
2. Make all fields `private` and `final`.
3. Avoid setters; initialize fields via the constructor.
4. Return deep copies of mutable objects in getters.

**Example**
<pre>
final class ImmutableClass {
    private final String name;
    private final int age;

    public ImmutableClass(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
</pre>

---

# 16. Shallow Copy vs Deep Copy

### Shallow Copy
- Copies references, not the actual objects.

### Deep Copy
- Creates new instances for all fields, ensuring complete independence.

**Example in Java**
<pre>
class Address {
    String city;

    public Address(String city) {
        this.city = city;
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // Shallow Copy
    }

    public Person deepClone() {
        return new Person(this.name, new Address(this.address.city)); // Deep Copy
    }
}
</pre>

---

# 17. Runtime Polymorphism (Dynamic Binding)

### What is Dynamic Binding?
When a method is called on a reference, the actual method executed is determined at runtime based on the object type.

**Example**
<pre>
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.sound(); // Output: Dog barks
    }
}
</pre>

### What Happens Under the Hood?
- The JVM uses the **vtable** (virtual method table) to determine the actual method implementation at runtime.

---

# 18. SOLID Principles in OOP

1. **Single Responsibility Principle (SRP)**:
   A class should have only one responsibility.
2. **Open/Closed Principle (OCP)**:
   Classes should be open for extension but closed for modification.
3. **Liskov Substitution Principle (LSP)**:
   Subtypes should be substitutable for their base types.
4. **Interface Segregation Principle (ISP)**:
   Avoid forcing a class to implement methods it doesn’t use.
5. **Dependency Inversion Principle (DIP)**:
   Depend on abstractions, not on concrete implementations.

---

# 19. Observer Pattern

### What is the Observer Pattern?
A behavioral design pattern where an object (publisher) notifies its dependents (subscribers) when its state changes.

**Example**
<pre>
interface Subscriber {
    void update(String news);
}

class NewsPublisher {
    private List<Subscriber> subscribers = new ArrayList<>();

    void subscribe(Subscriber sub) {
        subscribers.add(sub);
    }

    void notifySubscribers(String news) {
        for (Subscriber sub : subscribers) {
            sub.update(news);
        }
    }
}

class EmailSubscriber implements Subscriber {
    @Override
    public void update(String news) {
        System.out.println("Email received: " + news);
    }
}
</pre>

---

# 20. Aggregation vs Composition

### Aggregation
- A "has-a" relationship.
- The child object can exist independently of the parent.

**Example**
<pre>
class Engine {}

class Car {
    private Engine engine;
}
</pre>

### Composition
- A "part-of" relationship.
- The child object’s lifecycle depends on the parent.

**Example**
<pre>
class Engine {}

class Car {
    private final Engine engine = new Engine();
}
</pre>

### Key Difference
| Feature        | Aggregation                        | Composition                        |
|----------------|------------------------------------|------------------------------------|
| **Lifespan**   | Independent of parent              | Dependent on parent                |
| **Coupling**   | Loosely coupled                    | Strongly coupled                   |

# 11. Static Methods and Static Variables

### What are Static Methods and Variables?
- **Static Methods**: Belong to the class rather than any specific object.
- **Static Variables**: Shared among all instances of the class.

### When to Use?
- For utility methods (e.g., `Math.sqrt()`).
- To share common data across instances.

### Limitations
- Cannot access instance variables or methods directly.
- Cannot be overridden (but can be hidden).

**Example**
<pre>
class Example {
    static int counter = 0; // Static variable

    static void incrementCounter() { // Static method
        counter++;
    }
}
</pre>

---

# 12. Constructors

### What is a Constructor?
A special method used to initialize objects when they are created.

### Default Constructor vs Copy Constructor
- **Default Constructor**: No-argument constructor.
- **Copy Constructor**: Creates a new object by copying another object.

**Example**
<pre>
class Example {
    int value;

    // Default constructor
    Example() {
        value = 0;
    }

    // Copy constructor
    Example(Example obj) {
        this.value = obj.value;
    }
}
</pre>

---

# 13. Deep Copy vs Shallow Copy

### Shallow Copy
- Copies references, not the actual objects.

### Deep Copy
- Creates new instances for all fields.

**Example**
<pre>
class Address {
    String city;

    public Address(String city) {
        this.city = city;
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // Shallow Copy
    }

    public Person deepClone() {
        return new Person(this.name, new Address(this.address.city)); // Deep Copy
    }
}
</pre>

---

# 14. Final Classes and Methods in Java

### What are Final Classes and Methods?
- **Final Classes**: Cannot be extended.
- **Final Methods**: Cannot be overridden.

### Use Cases
- To prevent modification of critical functionality.
- To ensure immutability.

**Example**
<pre>
final class Example {
    final void display() {
        System.out.println("Final Method");
    }
}
</pre>

---

# 15. `==` Operator vs `.equals()` Method

### Key Differences
- **`==`**: Compares memory references.
- **`.equals()`**: Compares the content of objects.

**Example**
<pre>
String str1 = "Hello";
String str2 = new String("Hello");

System.out.println(str1 == str2);       // false
System.out.println(str1.equals(str2)); // true
</pre>

---

# 16. Garbage Collection in Java

### Purpose
Reclaims memory occupied by unreferenced objects.

### How It Works
- JVM automatically runs garbage collection.
- Uses algorithms like Mark-and-Sweep.

### Explicit Garbage Collection
<pre>
System.gc();
</pre>

---

# 17. Dynamic Method Dispatch

### Definition
Allows method resolution at runtime based on the object type.

**Example**
<pre>
class Parent {
    void display() {
        System.out.println("Parent Display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child Display");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child(); // Upcasting
        obj.display();            // Output: Child Display
    }
}
</pre>

---

# 18. `super` Keyword

### Usage
1. Access parent class methods.
2. Access parent class constructors.

**Example**
<pre>
class Parent {
    Parent() {
        System.out.println("Parent Constructor");
    }
}

class Child extends Parent {
    Child() {
        super(); // Calls parent constructor
        System.out.println("Child Constructor");
    }
}
</pre>

---

# 19. Dependency Injection (DI)

### What is DI?
A design pattern where dependencies are provided externally rather than created within a class.

**Example**
<pre>
interface Service {
    void execute();
}

class MyService implements Service {
    public void execute() {
        System.out.println("Service Executed");
    }
}

class Client {
    private Service service;

    Client(Service service) {
        this.service = service; // Dependency Injected
    }

    void performTask() {
        service.execute();
    }
}

public class Main {
    public static void main(String[] args) {
        Service service = new MyService();
        Client client = new Client(service);
        client.performTask();
    }
}
</pre>

---

# 20. Aggregation vs Composition

### Aggregation
- A "has-a" relationship.
- Child objects can exist independently.

**Example**
<pre>
class Engine {}

class Car {
    private Engine engine;
}
</pre>

### Composition
- A "part-of" relationship.
- Child objects' lifecycle depends on the parent.

**Example**
<pre>
class Engine {}

class Car {
    private final Engine engine = new Engine();
}
</pre>

### Key Difference
| Feature       | Aggregation                        | Composition                    |
|---------------|------------------------------------|--------------------------------|
| **Lifespan**  | Independent of parent             | Dependent on parent           |
| **Coupling**  | Loosely coupled                   | Strongly coupled              |  
  
  
  
  
# Miscellaneous OOP Questions

# 21. Difference Between a Class and an Object

### Class
- A blueprint or template for creating objects.
- Defines properties (fields) and behaviors (methods).

**Example**
<pre>
class Car {
    String brand;
    void drive() {
        System.out.println("Driving...");
    }
}
</pre>

### Object
- An instance of a class.
- Represents a specific entity with actual data.

**Example**
<pre>
Car myCar = new Car();
myCar.brand = "Toyota";
myCar.drive(); // Output: Driving...
</pre>

---

# 22. Purpose of Constructors in OOP

### What is a Constructor?
A special method used to initialize objects when they are created.

### Features
- Same name as the class.
- No return type.
- Can be parameterized or non-parameterized.

**Example**
<pre>
class Person {
    String name;

    // Constructor
    Person(String name) {
        this.name = name;
    }
}
</pre>

---

# 23. Static Methods and Fields in a Class

### Static Methods
- Belong to the class rather than an instance.
- Can be called without creating an object.

### Static Fields
- Shared among all instances of a class.

### When to Use
- Utility functions (e.g., `Math.sqrt()`).
- Shared data or constants.

**Example**
<pre>
class Example {
    static int count = 0; // Static field

    static void incrementCount() { // Static method
        count++;
    }
}
</pre>

---

# 24. Multiple Inheritance

### What is Multiple Inheritance?
When a class inherits from more than one class.

### Java
- **Not Supported**: To avoid ambiguity (Diamond Problem).
- Achieved through **interfaces**.

**Example**
<pre>
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class C implements A, B {
    public void methodA() {
        System.out.println("Method A");
    }

    public void methodB() {
        System.out.println("Method B");
    }
}
</pre>

### Python
- Supports multiple inheritance.
- Resolves conflicts using **MRO (Method Resolution Order)**.

**Example**
<pre>
class A:
    def method(self):
        print("Method from A")

class B:
    def method(self):
        print("Method from B")

class C(A, B):
    pass

obj = C()
obj.method()  # Output: Method from A (MRO prioritizes A)
</pre>

---

# 25. Memory Allocation for Objects in OOP

### Heap Memory
- Stores objects and instance variables.
- Managed by garbage collection.

### Stack Memory
- Stores method calls, local variables, and reference variables.
- Automatically deallocated when the method exits.

### Garbage Collection
- Reclaims memory for unreferenced objects.
- In Java: Automatically handled by JVM.
- Explicit call: `System.gc()` (not guaranteed).

---

# 26. Virtual Functions

### What are Virtual Functions?
- Functions that can be overridden in derived classes.
- Resolved at runtime using the **vtable** mechanism.

**Example in C++**
<pre>
class Base {
public:
    virtual void display() {
        cout << "Base Display";
    }
};

class Derived : public Base {
public:
    void display() override {
        cout << "Derived Display";
    }
};

int main() {
    Base* obj = new Derived();
    obj->display(); // Output: Derived Display
    return 0;
}
</pre>

---

# 27. Design Patterns and OOP Principles

### What are Design Patterns?
Reusable solutions to common software design problems.

### Relation to OOP Principles
- Encapsulation, inheritance, and polymorphism are often used to implement design patterns.

### Popular Patterns
1. **Singleton**:
   - Ensures only one instance of a class exists.
   - Use case: Logging, configuration management.
   <pre>
   class Singleton {
       private static Singleton instance;

       private Singleton() {}

       public static synchronized Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   </pre>

2. **Observer**:
   - Defines a one-to-many dependency between objects.
   - Use case: Event listeners.
   <pre>
   interface Subscriber {
       void update(String news);
   }

   class NewsPublisher {
       private List<Subscriber> subscribers = new ArrayList<>();

       void subscribe(Subscriber sub) {
           subscribers.add(sub);
       }

       void notifySubscribers(String news) {
           for (Subscriber sub : subscribers) {
               sub.update(news);
           }
       }
   }
   </pre>

3. **Builder**:
   - Separates object construction from its representation.
   - Use case: Creating complex objects step by step.
   <pre>
   class Car {
       private String color;
       private boolean hasSunroof;

       static class Builder {
           private String color;
           private boolean hasSunroof;

           Builder setColor(String color) {
               this.color = color;
               return this;
           }

           Builder setSunroof(boolean hasSunroof) {
               this.hasSunroof = hasSunroof;
               return this;
           }

           Car build() {
               return new Car(this);
           }
       }

       private Car(Builder builder) {
           this.color = builder.color;
           this.hasSunroof = builder.hasSunroof;
       }
   }
   </pre>
